# Первая лаба по проге

*Обратного пути нет. Все мы по началу думаем, что сможем завязать с программированием…*

<h4 align=right>Письмак</h4>

## Дисклеймер
В мануале с малой долей вероятности могут быть ошибки или неточности. Сообщить о них можно по VK : [https://vk.com/apploidxxx](https://vk.com/apploidxxx)

Этот мануал не сборник ответов к вопросам, которые зададут вам практики на первой лабе. Он скорее поможет вам достичь **цели** первой лабораторной работы - "понять с чем вы имеете дело".

Примеры привиденных кодов в каталоге `examples/manual-1`

## Язык Java. Особенности языка.
Меня всегда забавлял этот контрольный вопрос в описании первой лабораторной работы, потому что он слишком абстрактный и непонятно, что именно нужно знать и отвечать на этот вопрос.

Так в чем же особенность языка Java? Думаю, самая всем известная его особенность - это кроссплатформенность.

>Ну, кроссплатформенность это, конечно, хорошо, но каким образом она достигается? 

Чтобы понять это, давайте сначала рассмотрим прародитель языка Java, всеми известный C++. Вашу программу, написанную на языке Си, нужно будет компилировать под разные целевые платформы (Windows, Mac и прочее), которые будут работать только под них.

>А что значит компиляция? Почему под разные платформы вам нужно создать разные скомпилированные программы?

Опять появляется множество вопросов, на которые ответить, не зная основ компьютерной архитектуры - не так уж и просто ответить.

Начнем с архитектуры вашего любимого устройства:

![](https://commons.bmstu.wiki/images/b/b1/AC4.png)

Более подробную информацию вы можете найти [здесь](https://ru.bmstu.wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%B0) или прочитав книгу "Архитектура компьютера" Э.Таненбаума (я бы не советовал сейчас нагружать ваш мозг этим, но рано или поздно вам все равно, скорее всего, придется прочитать его (ОПД))

А здесь я попытаюсь рассказать вкратце и поверхностно.

Существует огромная разница между тем, что удобно людям, и тем что могут компьютеры. Мы хотим делать X, но компьютеры в то же время могут делать только Y. Из-за этого возникает проблема.

Эту проблему можно решить двумя способами. Оба подразумевают разработку новых команд, более удобных для человека, чем встроенные машинные команды. Эти новые команды в совокупности формируют язык, который будем называть Я1. Встроенные машинные команды - Я0. Компьютер может исполнять только программы, написанные на его машинном языке Я0.

Логично предположить, что в любом случае нам нужно **исполнить программу написанную на Я1, когда компьютеру доступен лишь язык Я0**.

Первый способ исполнения программы, написанной на языке Я1, подразумевает замену каждой команды эквивалентным набором команд на языке Я0. В этом случае компьютер исполняет новую программу, написанную на языке Я0, вместо старой программы, написанной на Я1. Эта технология называется **трансляцией**.

Трансляторы, которые транслируют программы на уровень 3 или 4 (см. рисунок выше), называются **компиляторами**.

Есть также второй способ, который заключается в создании на языке Я0 программы, получающей в качестве входных данных программы, написанные на языке Я1. При этом каждая команда языка Я1 обрабатывается поочередно, после чего сразу исполняется эквивалентный набор команд языка Я0. Эта технология не требует составления новой программы на Я0. Она называется **интерпретацией**, а программа которая осуществляет интерпретацию, называется **интерпретатором**.

А теперь представим себе **виртуальную машину**, для которой машинным языком является язык Я1. Назовем такую машину М1, а машину для работы с языком Я0 - М0. Если бы такую машину М1 можно было сконструировать без больших денежных затрат, язык Я0 был бы не нужен. Можно было бы писать программы сразу на языке Я1, а компьютер сразу бы их исполнял.  Тем не менее, такие машины, возможно, не удастся создать из-за чрезмерной дороговизны или трудностей разработки. Поэтому и появилось понятие виртуальная машина. Люди вполне могут писать ориентированные на неё программы. Эти программы будут транслироваться или интерпретироваться программой, написанной на языке Я0, а сама она могла бы исполняться существующим компьютером. Другими словами, можно писать программы для виртуальных машин так, будто эти машины реально существуют.
<br><br>
**JVM** - это виртуальная машина, но не стоит путать её с **System virtual machines** (которые могут обеспечивать функциональность, необходимую для выполнения целых операционных систем).

JVM относится к **Process virtual machines**, которые предназначены для выполнения компьютерных программ в независимой от платформы среде. Например, он исполняет **байт-код**, который можно считать языком Я1, а машина на которой стоит наш JVM (М1) это М0, умеющий выполнять программы Я0. Другими словами, JVM физически не существует - это по сути программа, написанная на языке Я0, которая может обрабатывать программы с языком Я1, интерпретируя его в язык Я0.

Таким образом, JVM разный под каждую платформу, так как ему нужно интерпретировать входную программу (байт-код) в программу, которую может понять конкретная платформа (Windows, Mac etc).

Давайте поймем разницу между байт-кодом (программа для JVM) и двоичным кодом, который понимает "процессор":

Вот пример машинного кода и его представления на языке Ассемблера. Слева указан порядковый номер (адрес) первого байта команды. Во второй колонке мы видим байты команды, они записаны в восьмеричной системе счисления. В третьей колонке мнемоники Ассемблера, которые упрощают восприятие программы человеком.
```asm
004: 003 010       lbl adda    #8      immediate value decimal
006: 103 010           addb    #010    same thing in octal
010: 024 001           lda     b       memory reference
012: 235 220           stx     (ptr)   indirect reference
014: 306 204           ora     data,x  indexed
016: 337 220           lnega   (ptr),x indirect/indexed
020:               # jumps and calls
020: 344 004           jmp     lbl     unconditional jump
022: 043 030           jane    lbl2-2  jump if a not equal 0
024: 257 221           jxgt    (ptr+one) jump indirect if x gt
026: 364 041           call    sub     call to subroutine
030: 174 220           cbeq    (ptr)   call indirect if b eq 0
032:               # set and skips
032:                   lbl2
032: 122 204           set1    fox,2  set bit 2 of data to 1
034: 272 205           skp0    data+1,7  skip if bit 7 is 0
036:               # shifts and rotates
036: 001               shra    1+SHIFT   shift a right 4 plcs
037: 361               rolb    2       rotate b left 2 places
040: 000               hlt             halt
041: 000               sub db 0            return address
042: 200               nop             no op
043: 023 222           lda #0222
045: 123 144           ldb #100
047: 360               sys             system call (extension)
050: 023 222           sysp 0222,100   system call using parms
052: 123 144
054: 360
055: 354 041           jmp (sub)       return
```

Не надо вдаваться в подробности, просто пример изнутри.

Теперь о байт-коде. Основной проблемой двоичного кода является его специфичность. Два разных устройства, например, ноутбук и мобильный телефон, имеют кардинально разные процессоры и кардинально разные наборы команд и кодов.

Один из способов проблемы переносимости и сложности это _промежуточная виртуальная машина_.

Виртуальный процессор работает также, как и реальный: он видит массив чисел, и воспринимает их как команды для выполнения. Байт-код внешне совершенно идентичен двоичному коду. Вот пример байт-кода виртуальной машины Java:
```asm
000: 03        iconst_0
001: 3b        istore_0
002: 84 00 01  iinc 0, 1
005: 1a        iload_0
006: 05        iconst_2
007: 68        imul
010: 3b        istore_0
011: a7 ff f9  goto -7
```
Единственная разница заключается в том, что двоичный код исполняет физический процессор, а байт-код — очень простая программа-интерпретатор.

Итак, сделаем заключение:
<hr>

**Байт-код** - это промежуточное представление программы, не привязанное к конкретной машинной архитектуре. Независимость от архитектуры машины обеспечивает переносимость, означающую, что уже разработанное (или скомпилированное) программное обеспечение может работать на любой платформе, поддерживающей JVM и абстракции языка Java.
<hr>

>В настоящее время язык программирования Java в значительной степени независим от виртуальной машины Java, так что буква "J" в аббревиатуре "JVM" немного вводит в заблуждение, поскольку JVM в состоянии выполнять любой язык JVM, который может сгенерировать корректный файл класса. Например, Scala, генерирующий байт-код для выполнения в JVM.

Как итог, можно сказать, что если вы напишите вашу программу в Windows (и допустим сделаете из него какой-нибудь jar-файл), то он сможет запуститься на Mac или Unix (по крайней мере, так задумано), если у них стоит JVM.

## Практика
Давайте напишем простую программу *Hello.java*:
```java
public class Hello {
        public static void main(String ... args){
                for(int i=0;i<10;i++){
                        System.out.println("ITMO");
                }
        }
}
```
Скомпилируем её с помощью команды `javac`:
```cmd
javac Hello.java
```
После того как вы её скомпилируете вы можете увидеть файл Hello.class - ваша скомпилированная программа, иначе говоря байт-код.

Запустить её можно командой `java`:
```
java Hello
```
*Прим. не надо указывать его расширение (.class) - необходимо и достаточно указать лишь его имя.*

Java поставляется с дизассемблером файлов классов под названием `jаvap`, который позволяет изучать .сlаss-файлы. Взяв файл класса Hello и запустив `javap -с Hello`, мы получим следующий результат:
```
Compiled from "Hello.java"
public class Hello {
  public Hello();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String...);
    Code:
       0: iconst_0
       1: istore_1
       2: iload_1
       3: bipush        10
       5: if_icmpge     22
       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      11: ldc           #3                  // String ITMO
      13: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      16: iinc          1, 1
      19: goto          2
      22: return
}
```

Опять же пока не стоит вдаваться в подробности (хотя в моей памяти, вроде и бывало что спрашивали про основные команды, например, `goto`, `bipush` или `istore`)

#### Осталось чуть-чуть
Итак, переходя ко второму контрольному вопросу: что же такое JVM, JRE и JDK?

С JVM мы в принципе более-менее разобрались - это виртуальная машина, на которой выполняются байт-коды.

JRE и JDK относительно проще, чем определение JVM:
* JRE ( **Java Runtime Environment**) - это среда выполнения Java - она, помимо прочего, содержит JVM и является тем, что вам нужно для запуска Java-программы. Она не содержит инструментов и утилит, таких как компиляторы или отладчики для разработки приложений.
* JDK (**Java Development Kit**)  - является расширенным набором JRE и содержит все, что есть в JRE, а также такие инструменты, как компиляторы и отладчики, необходимые для разработки.

## JIT-компиляция
Еще один из частых вопросов на лабах - что такое JIT-компиляция?

JIT (Just-in-Time, своевременная) компиляция появилась в HotSpot VM (см. приложение A), в котором  модули программы (интерпретированные из байт-кода) компилируются в машинный код. Модулями компиляции в HotSpot являются метод и цикл. 

JIТ-компиляция работает путем мониторинга приложения, выполняемого в режиме интерпретации, и выявления наиболее часто выполняемых фрагментов кода. В ходе анализа собирается информация, которая позволяет выполнять более сложную оптимизацию. Когда выполнение некоторого конкретного метода переходит установленный порог, профайлер запрашивает компиляцию и оптимизацию этого фрагмента кода. 

JIТ-подход к компиляции имеет много преимуществ, но одним из главных является то, что он основан на данных трассировки, собранной на этапе интерпретации, что позволяет HotSpot принять более обоснованные и разумные решения, касающиеся оптимизации.

После трансляции исходного кода Java в байт-код и еще одного этапа JIТ-компиляции фактически выполняемый код очень существенно отличается от написанного исходного кода. Это ключевой момент, который будет управлять нашим подходом к исследованиям производительности. Код после JIТ-компиляции, выполняющийся виртуальной машиной, может выглядеть не имеющим ничего общего с оригинальным исходным кодом на Java.

Пример инлайнинга JIT-компилятора можно увидеть здесь: [https://habr.com/ru/post/305894/](https://habr.com/ru/post/305894/)

## Переходя к программированию
Далее будут материалы касающееся непосредственно программирования на языке Java.

### Примитивные типы данных в Java

Рассмотрим примитивные типы в JVM:

Виртуальная машина Java поддерживает следующие примитивные типы: числовые типы,  boolean  тип и типы с плавающей точкой

#### Целые типы

-   **byte**, содержит 8-битовые знаковые целые. 
	- Значение по умолчанию - ноль.
-   **short**, содержит 16-битовые знаковые целые. 
	- Значение по умолчанию - ноль.
-   **int**, содержит 32-битовые знаковые целые. 
	- Значение по умолчанию - ноль.
-   **long**, содержит 64-битовые знаковые целые. 
	- Значение по умолчанию - ноль.
-   **char,** содержит 16-битовые беззнаковые целые, представляющие собой кодовые точки таблицы символов Unicode в базовой странице UTF-16. 
	- Значение по умолчанию - нулевая кодовая точка ('\u0000')

#### Типы с плавающей точкой

-   **float**, содержит числа с плавающей точкой одинарной точности. 
	- Значение по умолчанию - положительный ноль.
-   **double**, содержит числа с плавающей точкой двойной точности. 
	- Значение по умолчанию - положительный ноль.

Значение  boolean  типа может быть  `true`  или  `false`, значение по умолчанию  `false`.  

#### Целочисленные типы и их значения
Существуют следующие диапазоны для целочисленных значений:

-   для типа  **byte**  от -128 до 127 (-2^7^ до 2^7^  - 1) включительно;
-   для типа  **short**  от -32768 до 32767 (-2^15^  до 2^15^  - 1) включительно;
-   для типа  **int**  от -2147483648 до 2147483647 (-2^31^  до 2^31^  - 1) включительно;
-   для типа  **long**  от -9223372036854775808 до 9223372036854775807 (-2^63^  до 2^63^  - 1) включительно;
-   для типа  **char**  от 0 до 65535 включительно;

Запоминать эти значения наизусть не надо, но можно хотя бы примерно представлять их границы по степеням двойки.

Например, может попасться задача такого рода:
```java
public class ExampleWithByte{
	public static void main(String ... args){
		byte x = 127;
		x++;
		System.out.println(x);		//  -128
	}
}
``` 

Эта программа при исполнении выводит -128. Объяснить это очень просто, зная диапазоны типов данных. А почему именно -128 это вопрос к дискретке и двоичному представлению чисел в машине.

#### Типы данных с плавающей точкой, множества значений и значения

Типами данных с плавающей точкой являются типы  **float**  и  **double**  соответственно 32-х битые значения одинарной точности и 64-х битные значения двойной точности. Формат чисел и операции над ними соответствуют спецификации  _IEEE Standard for Binary Floating-Point Arithmetic_  (ANSI/IEEE Std. 754-1985, New York).

Стандарт IEEE 754 включает в себя не только положительные и отрицательные значения мантиссы, но также и положительные и отрицательные нули, положительные и отрицательные  _бесконечности_, и специальное не числовое значение **NaN** (Not-a-Number). NaN используется в качестве результата некоторых неверных операций, таких как деление нуля на нуль.
<br><br>
Все значения (кроме не-чисел NaN) множества чисел с плавающей точкой  _упорядочены_. Если числа упорядочить по возрастанию, то они образуют такую последовательность: отрицательная бесконечность, отрицательные конечные значения, отрицательный ноль, положительный ноль, положительные значения и положительная бесконечность.

Сравнивая положительный и отрицательный ноль, мы получим верное равенство, однако существуют операции, в которых их можно отличить; например, деля  1.0  на  0.0, мы получим положительную бесконечность, но деля  1.0  на  -0.0  мы получим отрицательную бесконечность.

Не-числа NaN  _не упорядочены_, так что сравнение и проверка на равенство вернёт  _ложь_, если хотя бы один из операндов не-число NaN. В частности проверка на равенство значения самому себе вернёт  _ложь_  тогда и только тогда, кода операнд не-число NaN. Проверка на неравенство вернёт  _истину_, когда хотя бы из операндов не-число NaN.

### JAR и манифесты
Статей про создание JAR и его приложений много, но бывает, что трудно понять даже простое, если ни разу не видели как это делается.

Приведу очень простой пример создания Jar-архива. Примеры будут в папке `examples/manual-1/jar`

Для начала создадим нашу программу и назовем её условно Lab.java:
```java
public class Lab {
	public static void main(String ... args) {
		System.out.println("it works on my machine");
	}
}
```

Скомпилируем:
```
javac Lab.java
```

Получим байт-код `Lab.class`. 

Чтобы запаковать его используем команду `jar` с параметрами `c` (create) и `f`(file).
```
jar cf Labpack.jar Lab.class
```

На выходе вы получите файл Labpack.jar, который запускается командой:
```
java -jar Labpack.jar
```

Но программа не исполнится как задумано, а вместо этого выведет:
```
no main manifest attribute, in .\Labpack.jar
```

Дело в том, что в таком jar-пакете может быть несколько файлов и исполняющая машина не может знать какую из них выполнить.

Чтобы указать ему наш класс для выполнения создадим файл `MANIFEST.MF`.

Есть несколько способов для Unix-подобных систем. Пользуйтесь таким какой вам удобнее

Вот внутренности MANIFEST.MF
```
Version: 6.6.6
Main-Class: Lab
```

Здесь мы указали версию нашего пакета, а самое главное точку входа (класс Lab)

Команда теперь будет выглядеть следующим образом:
```
jar cfm Labpack.jar MANIFEST.MF Lab.class
```

Здесь важно соблюдать порядок: 
1. Имя jar-пакета
2. Путь к манифесту
3. Классы

Запустив его предыдущей командой `java -jar Labpack.jar` мы получим:
```
it works on my machine
```

### Остальные контрольные вопросы
Мне не очень-то уж и хочется рассказывать про синтаксис языка Java - да, в некоторых из них есть не очевидные на первый взгляд нюансы, но проблем с базовыми вещами (for, for-each, while, do-while) быть не должно (тысячи и тысячи статей).

Поэтому я оставлю тут вопросы, на которые лучше знать ответ, и которые могут служить ориентиром:

```
1. Что такое JAR, для чего он нужен?
1.1 Что такое манифест, основные параметры (Main-Class, Version ...)
1.2 Как собирать JAR (консольная команда)

2. Чем отличаются (что такое) JDK, JRE и JVM
2.1 Что такое IDE?

3. Что такое компиляция? Какие виды еще есть (интерпретация, трансляция...(на будущее))?
3.1 Жизненный цикл Java программы

4. Почему программу написанную на Java можно запускать на любой платформе?
4.1 Какую роль в этом играет JVM?
4.2 Что такое байт-код?

5. Примитивные типы данных. Сколько их существует? Представление данных и их классификация
5.1 В чем различия double и float?
5.2 Сколько бит ответедено под каждый примитивный тип?
5.3 Константы (final). Можно ли не инициализировать константу при объявлении?
5.4 Преобразование и приведение типов. В чем отличие?
5.4 (Сложнаааа) В чем отличие примитивных и ссылочных типов данных?
5.5 В чем ошибка: byte a = 1, b =2; byte c = a + b;

6. Основные методы библиотеки Math
6.1 Вспомогательные пакеты Java. Пакет java.util (для чего он нужен).
6.1 Как хранятся эти пакеты?

7. Что такое NaN? В каких случаях он возникает и с какими типами данных?

8. Зарезервированные лексемы (continue, for, break, else ...)

9. Комментарии 3 вида (чучуть про джавадок) 

10. Линейные и нелинейные программы.
10.1 синтаксис while, do-while, switch, тернарный оператор, foreach-цикл
10.2 Что вы можете рассказать о конструкции: for(;;) { }
10.3 Какие типы данных могут быть использованы в операторе switch?
10.4 Как работает тернарный оператор?

11. Стандартные потоки (out, err, in)
11.1 Как использовать стандартные потоки ввода/вывода в Java?

12. java.util.Arrays - работа с массивами
12.1 Как устроены многомерные массивы?
12.2 Сколько элементов может хранить массив?

13. (Сложнааа) оператор "new"

14. Работа со строками (trim, replace ...). Тип данных String

15. (Сложнаааа, ни нада) goto в Java. Как ставить label?
```

## Приложение А. AOT- и JIT-компиляция

В этом разделе мы обсудим и сравним раннюю (Ahead-of-Time - AОТ) компиляцию и компиляцию оперативную (Just-in-Time - JIТ)

### AOT
Если у вас есть опыт программирования на таких языках, как С или С++, то вы знакомы с AОТ-компиляцией (возможно, вы всегда называли ее просто "компиляцией"). Это процесс, при котором внешняя программа (компилятор) принимает исходный текст (в удобочитаемом для человека виде) и на выходе дает непосредственно **исполняемый машинный код**.

>Ранняя компиляция исходного кода означает, что у вас есть только одна возможность воспользоваться преимуществами любых потенциальных оптимизации

Скорее всего, вы захотите создать исполняемый файл, предназначенный для конкретной платформы и архитектуры процессора, на которой вы собираетесь его запускать. Такие тщательно настроенные бинарные файлы смогут использовать любые преимущества процессора, которые могут ускорить работу программы. 

Однако в большинстве случаев исполняемый файл создается без знания конкретной платформы, на которой он будет выполняться. Это означает, что AОТ-компиляция должна делать консервативное предположение о том, какие возможности процессора могут быть доступны . Если код скомпилирован в предположении доступности некоторых возможностей, а затем все оказывается не так, этот бинарный файл не будет запускаться совсем .

Это приводит к ситуации, когда AОТ-скомпилированные бинарные файлы не в состоянии в полной мере использовать имеющиеся возможности процессора.

### JIT
Оперативная компиляция ("в точный момент времени") - это общая технология, когда программы преобразуются (обычно из некоторого удобного промежуточного формата) в высоко оптимизированный машинный код непосредственно во время выполнения. 

HotSpot и большинство других основных производителей JVM в значительной степени полагаются на применение этого подхода. При таком подходе во время выполнения собирается информация о вашей программе и создается профиль, который можно использовать для определения того, какие части вашей программы используются наиболее часто и больше всего выиграют от оптимизации.

Подсистема JIТ использует ресурсы VM совместно с вашей запущенной программой, поэтому стоимости такого профилирования и любых выполняемых оптимизаций должны быть сбалансированы с ожидаемым прирос ом производительности. 

Стоимость компиляции байт-кода в машинный код платится во время выполнения; компиляция расходует ресурсы (процессорное время, память), которые в противном случае могли бы быть использоваться для выполнения вашей программы. 

Поэтому JIТ-компиляция выполняется экономно, а VM собирает статистику о вашей программе (ищет "горячие пятна"), чтобы знать, где лучше всего выполнять оптимизацию.

## Приложение Б. Использованная литература
* Tim Lindholm, Frank Yellin - [JVM Specification Java SE8 Edition](https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf)
* Брюс Эккель - Философия Java
* Benjamin Evans - Optimizing Java. Practical techniques for improving JVM application performance
* Письмак А.Е. - [Конспекты лекций первого семестра](https://se.ifmo.ru/documents/10180/639377/%D0%9A%D0%BE%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82+%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9/f8e05cb1-0d5b-467c-b8b7-3c6681590cae)
* Э. Таненбаум - Архитектура компьютера
* Ну и как всегда `stackoverflow`
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE4MDYxODUzMl19
-->