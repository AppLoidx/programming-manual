# ООП в контексте Java (редактируется)

_Весь материал, который Вы понимаете, сразу применяйте на практике.
Придумывайте идеи и старайтесь реализовывать, используя то, чему
научились на занятиях или при самостоятельном изучении._

**Письмак**

<hr/>
## Объектно-Ориентированное Программирование

### Мини-вступление

Чтобы понять "Что такое ООП?" мне понадобилось 3 недели (если не считать, что задолго до этого пытался изучить ООП в контексте C# и Python), я уже мог пользоваться этими объектами и использовать в своем Java-коде (к слову, это была усложненная версия первой лабы). 

Но, по крайней мере, я так думал. На то, чтобы **действительно** понять всю суть ООП, у меня ушло намно-оо-го больше времени, и я до сих пор думаю, что не до конца понимаю ООП. 

К чему я это? К тому, что читая какую-нибудь статью - да, вы будете знать как использовать ООП в разных языках, но не сможете ощутить всю их прелесть не покодив порядочное количество проектов. В этом я согласен с Письмаком и полностью поддерживаю его слова.

### Для "опытных" пользователей компьютера

Если вы уже знаете что такое ООП на уровне свободного использования объектов на любом языке поддерживающим парадигму ООП, то сразу можете переходить к главе **"ООП в Java"**

Далее, мы рассмотрим ООП в общем плане, не привязывая чисто к Java, но для примеров будем использовать его.

### Канон

Обычно, люди когда объясняют про всякие объекты, классы, их методы и тд, они начинают с класса. Ну, это вполне логично, потому что **объект создается из класса**.

Но я поступлю иначе, и сначала попытаюсь объяснить "что такое объект?".

Давайте попробуем связать его определение с тем, что мы уже знаем. 

#### Кузнечик

Представим себе кузнечика. Пусть, это будет наш объект. 

Какие у него есть свойства? Например, длина, окрас и пускай у него еще будет имя Боб.

Итак, попробуем записать нашего Боба:



``` 
Grig(кузнечик){
	length: 5;
	color: brown;
	name: "Bob";
}
```

Прекрасно, а что он умеет делать? Скажем, например, прыгать. Давайте запишем это как функцию:

```
Grig{
	length: 5;
	color: brown;
	name: "Bob";
	
	function jump(){ "jump 25 cm" };
	function eat(){ "eat green grass" };
}
```

Теперь, у нас есть объект - у него свойства (length, color, name) и методы (действия в данном случае)(jump, eat). Здесь важно понимать, что jump и eat - это функции, то есть выполняют какую-то операцию.

Но, насколько бы он не был интровертом, думаю, ему все равно нужна пара, поэтому давайте создадим ему девушку:

```
Grig{
	length: 4.9;
	color: green;
	name: "Alice";
	
	function jump(){ "jump 25 cm" };
	function eat(){ "eat green grass" };
}
```

Когда у нас есть два объекта, попробуем сравнить их. У них те же имена свойств (length, color, name), но разные значения. В том числе, у них одинаковые имена методов (jump, eat).

А если у них имена всех свойств и методов совпадают - давайте сделаем какой-то шаблон, чтобы из него создавать эти объекты. Пусть, это будет шаблон с именем Grig и будем создавать эти объекты по этому шаблону. При этом функции везде одинаковые, поэтому пусть это сразу будет в шаблоне. Тогда нам нужно будет указать лишь уникальные свойства.

```
class Grig {
	length: null;
	color: null;
	name: null;
	
	function jump(){ "jump 25 cm" };
	function eat(){ "eat green grass" };
}
```

Как видите, мы не можем знать какие свойства будут у объекта, поэтому просто поставим там значения `null` . Отсюда и можно понять, что **класс - это не объект**, а сущность от которого эти объекты создаются.

Мы представили объект и класс как кузнечиков. А теперь попробуйте посмотреть вокруг себя внутри комнаты, на улице. Все является объектом! И ведь правда, любой встреченный человек - это объект из шаблона ( класса) человек. Или, например, лампа - у нее есть свой цвет, размер (свойства), к тому же она может светить (метод).

Здесь я бы хотел привести цитату, которую повторял мой учитель информатики. Она, вроде как я помню, была от Брюса Ли, а оригинал я не нашел, но суть была такая:

> Видеть Кунг-Фу во всем

Казалось бы не совсем понятная цитата и я сначала посмеялся, но мой учитель объяснил, что "кунг-фу" это образное выражение того, чем ты занимаешься. Ну, на тот момент эта цитата изменилась на "видеть программирование во всем, что нас окружает".

И вот однажды после пар на Кронверкской я направлялся на Горьковскую и неожиданно меня осенило: 

-- "Так вот же объекты, вот они проходят мимо меня, эти чертовы люди! Вот стоит машина, а ведь это тоже объект".

Так, восприятие моего мира изменилась, хотя на жизнь это вряд ли повлияло. 

### ООП в Java

В этой главе рассмотрим парадигмы ООП в контексте Java, потому что без конкретных примеров объяснить будет очень трудно, но следует заметить, что **парадигмы ООП встречаются во многих языках**, но имеют свою реализацию.

**Предисловие**: если вы понимаете парадигмы ООП и умеете применять их в стеке Java, то сразу можете переходить к главе со звездочкой **Стек и Куча**.

Итак, погружаемся в ООП...

<hr/>
Прежде чем приступить к парадигмам, научимся создавать объекты и классы в Java.

Примеры исходников можно найти в `examples/manual-2/basic`



Давайте реализуем наши классы кузнечиков в контексте Java:



*Листинг 1.1 FirstExample.java*

```java
class Grig {
    double length;
    String color;
    String name;

    void jump(){
        System.out.println(name + " is jumping");
    }

    void eat(){
        System.out.println(name + " is eating grass");
    }
}

public class FirstExample {
    public static void main(String[] args) {

        // создаем объект-кузнечик Bob
        Grig bob = new Grig();
        bob.name = "Bob";
        bob.length = 5d;
        bob.color = "brown";

        // создаем объект-кузнечик Alice
        Grig alice = new Grig();
        alice.name = "Alice";
        alice.length = 4.9d;
        alice.color = "green";

        
        bob.jump();     // output: Bob is jumping
        alice.jump();   // output: Alice is jumping
        
        bob.eat();      // output: Bob is eating grass
        alice.eat();    // output: Alice is eating grass

    }

}
```

Очень надеюсь, что мне не стоит объяснять как обращаться к свойствам (полям) или методам объекта. Так как вы, скорее всего, уже их использовали, например так:

```java
System.out.print("hello, onii-chan!")
```

Не сказал бы, что это совсем удачный пример, так как здесь затрагиваются статические поля, но не суть. Сначала вы обращаетесь к `out` и затем от него вызываете метод `print()`

По сути, `out` это **статическое** поле в классе `System` , который имеет несколько методов, в том числе и `print`  (что такое статическое разберем позже)



Вернемся к листингу и разберем все по полочкам:

1. Сначала мы **объявляем переменную** `bob`  с типом `Grig`. Замечаете определенные сходства с `String` (тут же и вопрос почему `String` нужно сравнивать через `equals`)?
2. А затем нам нужно **создать объект** из класса кузнечика и **присвоить** это **значение** к нашей переменной `bob`. Если с присвоением все понятно, то как создавать объекты из класса? По сути, также как и массивы - через оператор `new` . Его мы тоже разберем чуть позже.
3. Теперь как вы помните класс не может быть объектом, поэтому его поля не инициализированы то есть не имеют значений или же если быть корректнее - имеют значения по умолчанию. Если вы не помните или не знаете значения по умолчанию посмотрите предыдущий мануал.
   Значит, их нужно инициализировать, а сделали мы это очень тривиально и понятно.
4. Теперь можем попробовать вызвать методы класса, общаясь к ним через объекты (экземпляры)

#### Конструкторы

Согласитесь, неприятно и в общем-то неудобно задавать поля (свойства) класса вот так:

```java
Grig bob = new Grig();
bob.name = "Bob";
bob.length = 5d;
bob.color = "brown";
```

Тут на помощь к нам приходят конструкторы. Давайте сначала посмотрим его реализацию, а затем разберемся что к чему:

*Листинг 1.2 SecondExample :*

```java
public class SecondExample {
    static class Grig {
        double length;
        String color;
        String name;
        
        Grig(String grigsName, String grigsColor, double grigsLength){
            name = grigsName;
            color = grigsColor;
            length = grigsLength;
        }
        
        void jump(){ System.out.println(name + " is jumping"); }
        void eat(){ System.out.println(name + " is eating grass"); }
    }

    public static void main(String[] args) {
        // создаем объект-кузнечик Bob
        Grig bob = new Grig("Bob", "brown", 5d);
        
        // создаем объект-кузнечик Alice
        Grig alice = new Grig("Alice", "green", 4.9d);


        bob.jump();     // Bob is jumping
        alice.jump();   // Alice is jumping
        bob.eat();      // Bob is eating grass
        alice.eat();    // Alice is eating grass
    }
}
```

В основном все также, но сравните предыдущий пример инициализации полей, и вот такую:

```java
Grig bob = new Grig("Bob", "brown", 5d);
```

Здесь было бы уместно сказать  : "*Краткость - сестра таланта*"

> Не обращайте внимания на модификатор static перед объявлением класса, сейчас это к делу не относится! Вернемся к ней позже



Итак, если посмотреть изменения, то мы добавили что-то похожее на функцию, которое имеет такое же имя как у класса и к тому же не имеющий типа возвращаемого значения (даже `void` здесь не видно!):

```java
Grig(String grigsName, String grigsColor, double grigsLength){
    name = grigsName;
    color = grigsColor;
    length = grigsLength;
}
```

Но понять, что именно он делает мы можем - берем значения из аргументов нашей "псевдо-функции" и присваиваем их соответственно по значениям полей. Все просто!

Думаю, вы уже догадались откуда мы будем получать эти аргументы - при вызове `new Grig()`

Так, `Grig()` - это метод или нет? Попробуйте использовать `Grig()` как обычный метод :)

У вас будет ошибка компиляции, потому что, `Grig()` - это действительно метод (это можно сказать по его схожести объявления в классе), но как вы могли заметить - **он особенный** .

Если коротко, то:

> Конструктор - это специальный метод, который вызывается при создании нового объекта



Подождите! Мы же их вызывали раньше, а там ведь не было никаких методов!

```java
Grig bob = new Grig();
```

Да, если попробовать запустить его, добавив конструктор такого вида (который ничего не делает):

```
Grig(){
    
}
```

Код все равно будет рабочим, а это значит, что если созданный вами класс не имеет конструктора, **компилятор автоматически добавит конструктор по умолчанию**.

Это можно увидеть в байт-коде через команду `javap` (пример из предыдущего мануала):

```java
public class Hello {
        public static void main(String ... args){
                for(int i=0;i<10;i++){
                        System.out.println("ITMO");
                }
        }
}
```

Компилим и смотрим его байт-код:

```
Compiled from "Hello.java"
public class Hello {
  public Hello();
    Code:
       0: aload_0
       1: invokespecial #1    // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String...);
    Code:
       0: iconst_0
       1: istore_1
       2: iload_1
       3: bipush        10
       5: if_icmpge     22
       8: getstatic     #2    // Field java/lang/System.out:Ljava/io/PrintStream;
      11: ldc           #3    // String ITMO
      13: invokevirtual #4    // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      16: iinc          1, 1
      19: goto          2
      22: return
}
```

Мы не объявляли никакого конструктора, но в скомпилированной версии он есть. Его также именуют "***конструктором по умолчанию***" или в документации Java "*no-arg constructor*"

Следует заметить, что создание хотя бы одного конструктора уже отменяет автоматическое добавление конструктора по умолчанию.

Идем дальше, так в чем же заключается **особенность конструктора**?



Во-первых, **имя конструктора должно совпадать с именем класса**. Причиной этому стали две тонкости:

1. Любое имя, которое вы используете, может быть задействовано при определении членов класса, так возникает *конфликт имен*. 
2. *За вызов конструктора отвечает компилятор*, поэтому он всегда должен знать, какой именно метод следует вызвать.

Во-вторых, **у конструктора отсутствует возвращаемое значение**. Конструкторы никогда и ничего не возвращают (оператор `new` возвращает ссылку на вновь созданный объект, но сами конструкторы не имеют выходного значения). 

К слову, **в классе может быть несколько конструкторов**, но они как и методы, должны иметь разную сигнатуру (входные аргументы).



## Стек и куча

В этой главе речь пойдет о хранении данных в Java, в том числе про стек(stack) и куча(heap). И перед тем как приступить к этой главе, я бы настоятельно рекомендовал получше изучить объекты и их работу с ними. Попробуйте, например, воссоздать объекты из реального мира.

Самое главное, вам нужно понять как работать с ними.

Далее, идет глава не самая легкая для понимания. Если вы впервые сталкиваетесь с ООП, то тем более. Но это не говорит о том, что эту главу можно пропустить. Почитайте. Таким образом, вы восполните свой словарный запас и хотя бы на каком-то (очень абстрагированном ) уровне поймете принцип работы ООП в Java.

Когда-то, я начал читать книгу Джоша Лонга "*Java EE для предприятий*" . Там рассказывалось про архитектуру приложений в Java EE, но не суть. Дело в том, что мой уровень не позволял понять полностью, о чем в этой книге говорится, но я все равно читал.

И когда я одновременно с этим листал презентацию из se ifmo или из других источников, то сразу вспоминал слова находящиеся там и мог примерно понять, о чем идет речь.

К слову, эту книгу я перечитывал трижды и каждый раз одни и те же главы открывали для меня что-то новое, что я не мог увидеть раньше.

### Ссылочные типы

Виртуальная машина Java содержит явную поддержку объектов. Объектом мы называем динамически создаваемый экземпляр класса или массив. Ссылка на объект представлена в виртуальной машине Java типом `reference`. Значения типа reference могут быть рассмотрены как указатели на объекты. На один и тот же объект может существовать множество ссылок. Передача объектов, операции над объектами, проверка объектов происходит всегда посредством типа `reference`.

Так, `bob` и `alice` (наши переменные) являются ссылками на объекты.

Существуют три разновидности ссылочных (`reference`) типов: **тип класса, тип массива и тип интерфейса**. Значения этих типов представляют собой ссылки на экземпляр класса, ссылки на массив и ссылки на имплементацию интерфейса соответственно (про интерфейсы еще далеко).

Тип массива представляет собой *составной тип* единичной размерности (длина которого не определена типом). Каждый элемент составного типа сам по себе может также быть массивом. Последовательно рассматривая иерархию составных типов в глубину, (тип, из которого состоит составной тип, из которого состоит составной тип и т.д.) мы придём к типу, который не является массивом; он называется *элементарным типом* типа массив. Элементарный тип всегда либо примитивный тип, либо тип класса, либо тип интерфейса.

Тип `reference` может принимать специальное нулевое значение, так называемая ссылка на не существующий объект, которое обозначается как `null`. Значение `null` изначально не принадлежит ни к одному из ссылочных типов и может быть преобразовано к любому.

### Области данных в рантайме

#### Регистр PC

Виртуальная машина Java может поддерживать множество потоков, выполняющихся одновременно. Каждый поток виртуальной машины Java имеет свой регистр **pc** (*program counter*). В каждый момент времени каждый поток виртуальной машины исполняет код только одного метода, который называется текущим методом для данного потока. Если метод платформенно независимый (т.е. в объявлении метода не использовано ключевое слово `native`) регистр pc содержит адрес выполняющейся в данный момент инструкции виртуальной машины Java. Если метод платформенно зависимый (`native` метод) значение регистра **pc** не определено. 

#### Стек виртуальной машины Java

Каждый поток виртуальной машины имеет свой собственный *стек виртуальной машины Java*, создаваемый одновременно с потоком. Стек виртуальной машины хранит фреймы. 

Стек виртуальной машины Java аналогичен стеку в традиционных языках программирования: он хранит локальные переменные и промежуточные результаты и играет свою роль при вызове методов и при возврате управления из методов. Поскольку работать напрямую со стеком виртуальной машины Java запрещено (кроме операций `push` и `pop` для фреймов), фреймы могут быть также расположены в куче. Участок памяти для стека виртуальной машины Java не обязательно должен быть непрерывным.

В следующих случаях виртуальная машина Java формирует исключение при работе со стеком:

- Если вычисления в потоке требуют памяти более чем позволено размером стека, виртуальная машина Java формирует исключение `StackOverflowError`.
- Если стек виртуальной машины Java допускает динамическое увеличение размера и попытка такого увеличения была выполнена, однако вследствие нехватки памяти не завершена успешно либо не достаточно памяти при инициализации стека при создании потока, то виртуальная машина Java формирует исключение `OutOfMemoryError`.

Не будем подробно разбирать исключения, а это совсем отдельная тема, но если вы встретите их, то уже будете знать в чем дело (хотя и не факт, что сможете пофиксить)

#### Куча

Виртуальная машина Java содержит область памяти, называемую *кучей*, которая находится в пользовании всех потоков виртуальной машины. Куча – это область памяти времени выполнения, содержащая массивы и экземпляры всех классов.

Куча создаётся при запуске виртуальной машины Java. Удаление неиспользуемых объектов в куче производится системой автоматического управления памятью (известной как *сборщик мусора* (к этой теме мы еще вернемся)) 

Объекты никогда не удаляются явно. Виртуальная машина Java не предполагает какого-либо одного алгоритма для системы автоматического управления памятью; алгоритм может быть произвольно задан разработчиком виртуальной машины в зависимости от системных требований. Куча может быть фиксированного размера, либо динамически расширяться и сужаться при удалении объектов. 

Участок памяти для кучи виртуальной машины Java не обязательно должен быть непрерывным.



### Что и где хранится?

Мы рассмотрели два хранилища данных программы - стек и куча. Почему же их две и чем они отличаются?

Сначала, рассмотрим что такое стек и как она работает.

Во-первых, под стеком подразумевается  некоторый принцип хранения данных и обращения к данным. Обычно здесь можно привести в пример стопку тарелок. Мы можем положить тарелку сверху и взять тоже сверху. Такой принцип называется LIFO (Last-In-First-Out).

Согласитесь, довольно странный способ хранения информации, правда?

Давайте разберемся как он может пригодиться в нашей программе.



#### Зачем нужен стек в Java?

Давайте внесем немножко Java в свою жизнь:

*Листинг 2.1 DataExample.java*

```java
public class App {
 public static void main(String[] args) {
     System.out.print("Enter a:");
     int a = Integer.parseInt(System.console().readLine());
     System.out.print("Enter b:");
     int b = Integer.parseInt(System.console().readLine());
     System.out.println("a+b=" + pow(a,b));
 }
 public static Long pow(int base, int exponent) {
     Long result = 1L;
     for (int i = 0; i < exponent; i++) {
          result *= base;
     }
     return result;
 }
}
```

Давайте сначала рассмотрим только метод main.

Какие у нас данные? Во-первых, это наши переменные `a`,`b`. Также, у нас входные данные `args`. Итого, мы насчитали 3, давайте это проверим, запустив команду:

```
javap -v -c DataExample
```

Пропускаем оттуда пул констант и переходим сразу к этому:

```
  public DataExample();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 4: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=3, args_size=1	// <----------- [ ЗДЕСЬ ] !!!
         0: getstatic     #2         
         3: ldc           #3         // String Enter a:
         5: invokevirtual #4                  
         8: invokestatic  #5                  
        11: invokevirtual #6                  
        14: invokestatic  #7                  
        17: istore_1
        18: getstatic     #2                  
        21: ldc           #8         // String Enter b:
        23: invokevirtual #4                  
        26: invokestatic  #5                  
        29: invokevirtual #6                  
        32: invokestatic  #7                  
        35: istore_2
        36: getstatic     #2                  
        39: new           #9          // class java/lang/StringBuilder
        42: dup
        43: invokespecial #10                 
        46: ldc           #11         // String a+b=
        48: invokevirtual #12                 
        51: iload_1
        52: iload_2
        53: invokestatic  #13         // Method pow:(II)Ljava/lang/Long;
        56: invokevirtual #14                 
        59: invokevirtual #15                 
        62: invokevirtual #16                 
        65: return
	
	 public static java.lang.Long pow(int, int);
	 // к методу pow мы вернемся позже
}
SourceFile: "DataExample.java"
```



Давайте обратим внимание на строку : `stack=4, locals=3, args_size=1`. Как видно из неё, мы оказались правы - 3 локальные переменные, в том числе одна из них это входные данные

Разберем значения этих трех свойств:

* `stack` - максимальный размер стека, необходимый для выполнения процедуры
* `locals` - локальные переменные
* `args_size` - входные данные (на самом деле, просто те данные, которые есть до того как выполнится процедура). Есть парочка интересных моментов с ней, поэтому мы еще вернемся к этому параметру.

Теперь посмотрим на метод `pow` :

```

  public static java.lang.Long pow(int, int);
    descriptor: (II)Ljava/lang/Long;
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=4, args_size=2
         0: lconst_1			
         1: invokestatic  #14   
         4: astore_2
         5: iconst_0
         6: istore_3
         7: iload_3
         8: iload_1
         9: if_icmpge     29
        12: aload_2
        13: invokevirtual #15  
        16: iload_0
        17: i2l
        18: lmul
        19: invokestatic  #14    
        22: astore_2
        23: iinc          3, 1
        26: goto          7
        29: aload_2
        30: areturn
      LineNumberTable:
        line 10: 0
        line 11: 5
        line 12: 12
        line 11: 23
        line 14: 29
      StackMapTable: number_of_entries = 2
        frame_type = 253 /* append */
          offset_delta = 7
          locals = [ class java/lang/Long, int ]
        frame_type = 250 /* chop */
          offset_delta = 21
```



Здесь для выполнения операций нужно четыре слота стека 

Также, мы имеем два аргумента и еще две локальные переменные - `result` и `i` 



**Задачка для тех, кто умеет работать с ООП**

```java
public class Test {
   public void plus(){
	int a = 1;
    int b = 3;
   }
 }
// stack=1, locals=3, args_size=1
```

Разберите в этом примере, почему в стеке нам нужен лишь один слот и почему у нас три локальных переменных. (*Подсказка*: args_size тоже входит в их число)



Смотрите сюда, если вы не смогли узнать сами почему там `args_size = 1` или сделали какое-нибудь предположение, следующая подсказка:

```java
public class Test {
   public static void plus(){
	int a = 1;
    int b = 3;
   }
 }
// stack=1, locals=2, args_size=0
```



